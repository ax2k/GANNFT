import { Injectable } from '@angular/core';
import { ethers } from 'ethers';
import { BehaviorSubject } from 'rxjs';

import { ERC20Abi, NFTAbi } from '../models/contract-abi';


@Injectable({
  providedIn: 'root',
})
export class EthereumService {
  /**
   * Provider of ethereum service normally generated by 3rd party services like Metamask.
   */
  provider$: BehaviorSubject<ethers.providers.StaticJsonRpcProvider> = new BehaviorSubject({} as ethers.providers.StaticJsonRpcProvider);

  /**
   * Signer of ethereum service normally generated by 3rd party services like Metamask.
   */
  signer: ethers.providers.JsonRpcSigner | null = null;
  walletSigner: BehaviorSubject<ethers.Wallet> = new BehaviorSubject({} as ethers.Wallet);

  /**
   * Current account$ of ethereum service normally generated by 3rd party services like Metamask.
   */
  currentAccount$ = new BehaviorSubject('');

  /**
   * Observer for referral code.
   */
  referralCodeSubject$ = new BehaviorSubject('');

  NFTAddress = '';
  GAPEAddress = '0xBaE6f981dc151CfC633212f06A9c5B4E37920454';
  GAPEs = 0;

  balanceETH = 0;

  priceRegular = 0.1;
  priceGape = 0.05;


  /**
   * NFTs owned
   */
  NFTs : number[] = [];

  constructor() {}


  /**
   * Gets ETH balance
   * @returns
   */
  async getETHBalance() {
    if (!this.provider$) return console.error('No provider');

    await this.provider$.value.getBlockNumber();
    const balance = await this.provider$.value.getBalance(this.currentAccount$.value);
    this.balanceETH = parseFloat(ethers.utils.formatEther(balance));
  }  

  /**
  * Gets all the nfts owned by an account
  * @returns
  */
  async getNFTs() {
    if (!this.provider$.value) return console.error('No provider');

    const contracts = new ethers.Contract(this.NFTAddress, NFTAbi, this.provider$.value);

    const balance = await contracts.balanceOf(this.currentAccount$.value);
    
    //check balance
    if (balance > 0) {
      let nfts = []
      for (let index = 0; index < parseInt(balance); index++) {
        const nft = await contracts.tokenOfOwnerByIndex(this.currentAccount$.value, index) 
        nfts.push(parseInt(nft))
      }
      //copy nfts to nft array
      this.NFTs = nfts
    }  
  }

  /**
  * Gets all the Gapes
  * @returns
  */
   async getGapes() {
    if (!this.provider$.value) return console.error('No provider');

    const contracts = new ethers.Contract(this.GAPEAddress, NFTAbi, this.provider$.value);

    this.GAPEs = await contracts.balanceOf(this.currentAccount$.value);   
  }

   /**
   * Regular mint
   * @param amount
   * @param price
   * @returns token
   */
    async mint(amount: number): Promise<void> {
      if (!this.signer) return console.error('No signer');  
  
      const contracts = new ethers.Contract(this.NFTAddress, NFTAbi, this.signer); 
      const payment = this.priceRegular * amount;

      try {
        await contracts.mint(amount, {
          value: ethers.utils.parseUnits(payment.toString(), 18)
        });
      } catch (error) {
        return console.error('User denied signature.', error);
      }
    }

    /**
   * Mint with Gapes
   * @param amount
   * @param price
   * @returns token
   */
    async mintGAPE(amount: number): Promise<void> {
      if (!this.signer) return console.error('No signer');  
  
      const contracts = new ethers.Contract(this.NFTAddress, NFTAbi, this.signer); 
      const payment = this.priceGape * amount;

      try {
        await contracts.mintGAPE(amount, {
          value: ethers.utils.parseUnits(payment.toString(), 18)
        });
      } catch (error) {
        return console.error('User denied signature.', error);
      }
    }
}
